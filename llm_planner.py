# llm_planner.py
# LLM-Powered Trip Planner - Dynamic planning for any city in the world
# Uses Anthropic Claude as the reasoning engine for intelligent trip planning

import os
import json
import re
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
from anthropic import Anthropic
from dotenv import load_dotenv

from intent import TripIntent
from planner import ItineraryItem, DayRange, Itinerary
from data_sources import fetch_pois, get_supported_cities

# Load environment variables
load_dotenv()


@dataclass
class LLMGeneratedPOI:
    """POI generated by LLM for cities not in static database."""
    name: str
    area: str
    description: str
    tags: List[str]
    estimated_duration: str  # e.g., "2-3 hours"
    best_time_to_visit: str  # e.g., "Morning", "Afternoon", "Evening"
    opening_hours: str  # e.g., "9:00-18:00"
    google_maps_query: str  # For generating URLs


class LLMTripPlanner:
    """
    Advanced trip planner powered by Claude AI.
    
    Features:
    - Plans trips for ANY city in the world
    - Generates contextual POIs and activities
    - Creates intelligent day-by-day itineraries
    - Adapts to user preferences and trip length
    - Provides local insights and recommendations
    """

    def __init__(self, api_key: str = None):
        self.api_key = api_key or os.getenv("ANTHROPIC_API_KEY")
        if not self.api_key:
            raise ValueError("ANTHROPIC_API_KEY not found in environment variables")
        
        self.client = Anthropic(api_key=self.api_key)

    def plan_trip(self, intent: TripIntent) -> Itinerary:
        """
        Create a complete trip itinerary using AI reasoning.
        
        Strategy:
        1. Check if city is in static database first (for consistency)
        2. If not, use LLM to generate POIs and plan itinerary
        3. Create intelligent day-by-day schedule
        4. Handle any trip length (1 day to 1000+ days)
        """
        city = intent.destination
        days = intent.days or 3
        preferences = intent.preferences or []

        # First, try static database for supported cities
        static_pois = fetch_pois(city, preferences)
        if static_pois:
            # City is in our database - use hybrid approach
            return self._plan_with_hybrid_data(intent, static_pois)
        
        # City not in database - use full LLM planning
        return self._plan_with_llm(intent)

    def _plan_with_hybrid_data(self, intent: TripIntent, static_pois: List[dict]) -> Itinerary:
        """
        Plan trip using combination of static data and LLM reasoning.
        Enhances static POIs with AI-generated recommendations.
        """
        city = intent.destination
        days = intent.days or 3
        preferences = intent.preferences or []

        # Use LLM to enhance and organize the static POIs
        enhanced_itinerary = self._enhance_static_itinerary(intent, static_pois)
        
        # If trip is longer than available POIs, generate additional activities
        if days > len(static_pois) // 2:  # Rough heuristic
            additional_pois = self._generate_additional_pois(intent, static_pois)
            enhanced_itinerary = self._merge_itineraries(enhanced_itinerary, additional_pois)

        return enhanced_itinerary

    def _plan_with_llm(self, intent: TripIntent) -> Itinerary:
        """
        Plan complete trip using LLM for cities not in static database.
        """
        city = intent.destination
        days = intent.days or 3
        preferences = intent.preferences or []

        # Generate POIs using LLM
        generated_pois = self._generate_pois_with_llm(intent)
        
        if not generated_pois:
            return self._create_fallback_itinerary(intent)

        # Create detailed itinerary
        return self._create_llm_itinerary(intent, generated_pois)

    def _generate_pois_with_llm(self, intent: TripIntent) -> List[LLMGeneratedPOI]:
        """
        Generate POIs and attractions for any city using Claude AI.
        """
        city = intent.destination
        days = intent.days or 3
        preferences = intent.preferences or []
        
        # Calculate how many POIs we need
        # Aim for 2-4 activities per day for first week, then taper off
        base_pois_needed = min(days * 3, 21)  # Max 21 for first week
        if days > 7:
            # Add fewer POIs for remaining days
            additional_days = days - 7
            additional_pois = max(1, additional_days // 2)  # 1 POI per 2 days
            total_pois_needed = base_pois_needed + additional_pois
        else:
            total_pois_needed = base_pois_needed

        preference_text = ", ".join(preferences) if preferences else "general sightseeing and local experiences"

        prompt = f"""You are an expert travel guide creating a comprehensive list of attractions and activities for {city}.

TRIP DETAILS:
- Destination: {city}
- Duration: {days} days
- Interests: {preference_text}
- Number of POIs needed: {total_pois_needed}

Please generate a diverse list of {total_pois_needed} points of interest including:
- Major tourist attractions and landmarks
- Local cultural experiences
- Food and dining recommendations
- Hidden gems and local favorites
- Activities that match the specified interests
- Mix of indoor/outdoor activities
- Various price points (free to premium)

For each POI, provide this EXACT JSON format:
{{
    "name": "Official name of the place",
    "area": "Neighborhood or district name",
    "description": "2-3 sentence description highlighting what makes it special",
    "tags": ["list", "of", "relevant", "tags"],
    "estimated_duration": "Time needed (e.g., '2-3 hours', '30 minutes', 'Half day')",
    "best_time_to_visit": "Optimal time (e.g., 'Morning', 'Afternoon', 'Evening', 'Any time')",
    "opening_hours": "Typical hours (e.g., '9:00-18:00', '24/7', 'Varies')",
    "google_maps_query": "Exact search term for Google Maps"
}}

Use these tag categories when relevant: {', '.join(['food', 'culture', 'museum', 'art', 'architecture', 'nature', 'outdoors', 'nightlife', 'shopping', 'family', 'kids', 'history', 'beach', 'hiking', 'sports', 'adventure', 'relaxation'])}

Return ONLY a valid JSON array of POI objects, no other text."""

        try:
            message = self.client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=4000,
                temperature=0.7,
                messages=[{"role": "user", "content": prompt}]
            )

            response_text = message.content[0].text
            
            # Extract JSON from response
            json_match = re.search(r'\[.*\]', response_text, re.DOTALL)
            if not json_match:
                print(f"No JSON array found in LLM response for {city}")
                return []

            pois_data = json.loads(json_match.group())
            
            # Convert to LLMGeneratedPOI objects
            generated_pois = []
            for poi_dict in pois_data:
                try:
                    poi = LLMGeneratedPOI(
                        name=poi_dict.get("name", "Unknown Location"),
                        area=poi_dict.get("area", "Unknown Area"),
                        description=poi_dict.get("description", ""),
                        tags=poi_dict.get("tags", []),
                        estimated_duration=poi_dict.get("estimated_duration", "2-3 hours"),
                        best_time_to_visit=poi_dict.get("best_time_to_visit", "Any time"),
                        opening_hours=poi_dict.get("opening_hours", "9:00-18:00"),
                        google_maps_query=poi_dict.get("google_maps_query", poi_dict.get("name", ""))
                    )
                    generated_pois.append(poi)
                except Exception as e:
                    print(f"Error parsing POI: {e}")
                    continue

            print(f"Generated {len(generated_pois)} POIs for {city}")
            return generated_pois

        except Exception as e:
            print(f"Error generating POIs with LLM: {e}")
            return []

    def _create_llm_itinerary(self, intent: TripIntent, generated_pois: List[LLMGeneratedPOI]) -> Itinerary:
        """
        Create a detailed day-by-day itinerary using LLM reasoning.
        """
        city = intent.destination
        days = intent.days or 3
        preferences = intent.preferences or []

        # Convert POIs to JSON for LLM processing
        pois_for_llm = [asdict(poi) for poi in generated_pois]

        prompt = f"""You are an expert travel planner creating a detailed {days}-day itinerary for {city}.

TRIP DETAILS:
- Destination: {city}
- Duration: {days} days
- Traveler interests: {', '.join(preferences) if preferences else 'general tourism'}

AVAILABLE ATTRACTIONS:
{json.dumps(pois_for_llm, indent=2)}

PLANNING GUIDELINES:
1. Create a logical day-by-day schedule
2. Group activities by geographic area to minimize travel time
3. Consider optimal visiting times and opening hours
4. Balance different types of activities (culture, food, relaxation, etc.)
5. For trips over 7 days, include rest days or free time
6. For very long trips (30+ days), summarize later periods as "rest days" or "exploration time"

TIME SLOTS:
- 09:00 (Morning)
- 12:00 (Midday) 
- 15:00 (Afternoon)
- 18:00 (Evening)

For each activity, provide this EXACT JSON format:
{{
    "day": 1,
    "time": "09:00",
    "activity_name": "Name from the POI list",
    "area": "Area from POI",
    "reasoning": "Why this activity fits this time slot"
}}

RESPONSE FORMAT:
{{
    "itinerary_items": [array of activity objects],
    "day_ranges": [
        {{
            "start_day": 8,
            "end_day": 10,
            "description": "Rest and free exploration",
            "activity_type": "free_exploration"
        }}
    ],
    "planning_notes": "Brief explanation of the itinerary structure"
}}

Create an itinerary that covers all {days} days. Use day_ranges for periods longer than 7 days or when you run out of specific activities.

Return ONLY valid JSON, no other text."""

        try:
            message = self.client.messages.create(
                model="claude-3-haiku-20240307",
                max_tokens=4000,
                temperature=0.3,  # Lower temperature for more structured output
                messages=[{"role": "user", "content": prompt}]
            )

            response_text = message.content[0].text
            
            # Extract JSON from response
            json_match = re.search(r'\{.*\}', response_text, re.DOTALL)
            if not json_match:
                print("No JSON found in LLM itinerary response")
                return self._create_simple_fallback_itinerary(intent, generated_pois)

            itinerary_data = json.loads(json_match.group())
            
            # Convert to ItineraryItem objects
            items = []
            for item_dict in itinerary_data.get("itinerary_items", []):
                try:
                    # Find matching POI for URL
                    poi_name = item_dict.get("activity_name", "")
                    matching_poi = next((poi for poi in generated_pois if poi.name == poi_name), None)
                    url = f"https://maps.google.com/?q={matching_poi.google_maps_query}" if matching_poi else f"https://maps.google.com/?q={poi_name} {city}"
                    
                    # Find tags from matching POI
                    tags = matching_poi.tags if matching_poi else []

                    item = ItineraryItem(
                        day=item_dict.get("day", 1),
                        time=item_dict.get("time", "09:00"),
                        name=poi_name,
                        area=item_dict.get("area", "Unknown"),
                        tags=tags,
                        url=url
                    )
                    items.append(item)
                except Exception as e:
                    print(f"Error parsing itinerary item: {e}")
                    continue

            # Convert day ranges
            day_ranges = []
            for range_dict in itinerary_data.get("day_ranges", []):
                try:
                    day_range = DayRange(
                        start_day=range_dict.get("start_day", 1),
                        end_day=range_dict.get("end_day", 1),
                        description=range_dict.get("description", "Free time"),
                        activity_type=range_dict.get("activity_type", "free_exploration")
                    )
                    day_ranges.append(day_range)
                except Exception as e:
                    print(f"Error parsing day range: {e}")
                    continue

            # Ensure all days are covered
            itinerary = Itinerary(
                destination=city,
                days=days,
                items=items,
                day_ranges=day_ranges
            )

            # Fill any gaps
            covered_days = itinerary.get_all_covered_days()
            uncovered_days = [d for d in range(1, days + 1) if d not in covered_days]
            
            if uncovered_days:
                # Group consecutive uncovered days into ranges
                ranges = self._group_consecutive_days(uncovered_days)
                for start, end in ranges:
                    day_ranges.append(DayRange(
                        start_day=start,
                        end_day=end,
                        description="Free exploration time",
                        activity_type="free_exploration"
                    ))

            return itinerary

        except Exception as e:
            print(f"Error creating LLM itinerary: {e}")
            return self._create_simple_fallback_itinerary(intent, generated_pois)

    def _create_simple_fallback_itinerary(self, intent: TripIntent, generated_pois: List[LLMGeneratedPOI]) -> Itinerary:
        """
        Create a simple itinerary when LLM planning fails.
        """
        city = intent.destination
        days = intent.days or 3
        
        items = []
        time_slots = ["09:00", "12:00", "15:00", "18:00"]
        
        # Simple round-robin assignment
        for day in range(1, min(days + 1, 8)):  # Limit to first week
            for slot_idx, time_slot in enumerate(time_slots):
                poi_idx = ((day - 1) * len(time_slots) + slot_idx) % len(generated_pois)
                if poi_idx < len(generated_pois):
                    poi = generated_pois[poi_idx]
                    items.append(ItineraryItem(
                        day=day,
                        time=time_slot,
                        name=poi.name,
                        area=poi.area,
                        tags=poi.tags,
                        url=f"https://maps.google.com/?q={poi.google_maps_query}"
                    ))

        # Add day ranges for remaining days
        day_ranges = []
        if days > 7:
            day_ranges.append(DayRange(
                start_day=8,
                end_day=days,
                description="Free exploration and rest time",
                activity_type="free_exploration"
            ))

        return Itinerary(
            destination=city,
            days=days,
            items=items,
            day_ranges=day_ranges
        )

    def _create_fallback_itinerary(self, intent: TripIntent) -> Itinerary:
        """
        Create a basic itinerary when all LLM attempts fail.
        """
        city = intent.destination or "Unknown"
        days = intent.days or 3
        
        items = [
            ItineraryItem(
                day=1,
                time="09:00",
                name=f"Explore {city} City Center",
                area="City Center",
                tags=["culture"],
                url=f"https://maps.google.com/?q={city}+city+center"
            ),
            ItineraryItem(
                day=1,
                time="15:00",
                name=f"Local Food Experience in {city}",
                area="Local Area",
                tags=["food"],
                url=f"https://maps.google.com/?q={city}+local+food"
            )
        ]

        day_ranges = []
        if days > 1:
            day_ranges.append(DayRange(
                start_day=2,
                end_day=days,
                description="Free time to explore based on your interests. I recommend searching for local attractions, restaurants, and activities online.",
                activity_type="free_exploration"
            ))

        return Itinerary(
            destination=city,
            days=days,
            items=items,
            day_ranges=day_ranges
        )

    def _group_consecutive_days(self, days: List[int]) -> List[Tuple[int, int]]:
        """Group consecutive days into ranges."""
        if not days:
            return []

        ranges = []
        start = days[0]
        prev = days[0]

        for day in days[1:]:
            if day == prev + 1:
                prev = day
            else:
                ranges.append((start, prev))
                start = day
                prev = day

        ranges.append((start, prev))
        return ranges

    def _enhance_static_itinerary(self, intent: TripIntent, static_pois: List[dict]) -> Itinerary:
        """
        Enhance static POI data with LLM reasoning for better organization.
        """
        # For now, fall back to the original planner for static cities
        # This maintains consistency while adding LLM enhancement
        from planner import build_itinerary
        return build_itinerary(intent)

    def _generate_additional_pois(self, intent: TripIntent, existing_pois: List[dict]) -> List[LLMGeneratedPOI]:
        """
        Generate additional POIs to complement existing static data.
        """
        # This would use LLM to suggest additional activities beyond the static database
        return []

    def _merge_itineraries(self, base_itinerary: Itinerary, additional_pois: List[LLMGeneratedPOI]) -> Itinerary:
        """
        Merge additional LLM-generated POIs into existing itinerary.
        """
        # For now, return the base itinerary
        return base_itinerary


def create_intelligent_itinerary(intent: TripIntent, use_llm: bool = True) -> Itinerary:
    """
    Main function to create trip itinerary using LLM reasoning.
    
    Args:
        intent: Parsed trip intent
        use_llm: Whether to use LLM planning (falls back to static if False or API unavailable)
    
    Returns:
        Complete trip itinerary
    """
    if not use_llm or not os.getenv("ANTHROPIC_API_KEY"):
        # Fall back to static planner
        from planner import build_itinerary
        return build_itinerary(intent)
    
    try:
        llm_planner = LLMTripPlanner()
        return llm_planner.plan_trip(intent)
    except Exception as e:
        print(f"LLM planning failed, falling back to static planner: {e}")
        from planner import build_itinerary
        return build_itinerary(intent)